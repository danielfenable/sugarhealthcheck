<?php
if(!defined('sugarEntry') || !sugarEntry) die('Not A Valid Entry Point');
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

require_once 'include/utils/file_utils.php';

/**
 * File and class loader
 * @api
 */
class SugarAutoLoader
{
    const CACHE_FILE = "file_map.php";
    const CLASS_CACHE_FILE = "class_map.php";

    /**
     * Root namespace
     */
    const NS_ROOT = 'Sugarcrm\\Sugarcrm\\';

    /**
     * Direct class mapping
     * @var array name => path
     */
    public static $classMap = array();

    /**
     * Flag class map as dirty to flush update to cache
     * @var boolean
     */
    public static $classMapDirty = false;

    /**
     * Classes not to be loaded
     * @var array name => boolean
     */
    public static $noAutoLoad = array(
        'Tracker'=>true,
        // this one is generated by ViewFactory for classic view, but if never actually exists
        'UsersViewClassic'=>true,
    );

    /**
     * @var array
     */
    public static $moduleMap = array();

    /**
     * Class prefixes
     * Classes are loaded by prefix:
     * SugarAclFoo.php => data/acl/SugarACLFoo.php
     * @var array prefix => directory
     */
    public static $prefixMap = array(
        'SugarACL' => "data/acl/",
        'SugarWidget' => "include/generic/SugarWidgets/",
        'Zend_' => 'vendor/',
        'SugarJob' => 'include/SugarQueue/jobs/',
        'MetaDataContext' => 'modules/ModuleBuilder/parsers/MetaDataContext/',
        'MetaDataManager' => 'include/MetaDataManager/',
    );

    /**
     * Namespace directory mapping
     * - Prefix should include trailing \
     * - Directory should NOT contain trailing /
     *
     * Order is important on overlapping prefixes, first match wins !
     *   'Sugarcrm\\lib\\' => 'include'
     *   'Sugarcrm\\' => ''
     *   ...
     *
     * To add namespaces dynamically it's advised to use `self::addNamespace`
     * as this method will ensure a correct order from more to less
     * specific namespace prefixes. Also every prefix supports multiple
     * paths which are iterated in order to find a match.
     *
     * A better way to introduce new namespaces is by loading your libraries
     * through composer.json. The namespace definition as per the autoload
     * section will be automatically honored by this autoloader and avoids
     * the need of programmatically adding new namespaces using addNameSpace.
     *
     * @var array nsPrefix => array(directories)
     */
    public static $namespaceMap = array();

    /**
     * @var array nsPrefix => array(directories)
     * @see self::$namespaceMap
     */
    public static $namespaceMapPsr4 = array();

    /**
	 * Class loading directories
	 * Classes in these dirs are loaded by class name:
	 * Foo -> $dir/Foo.php
	 * @var array paths
	 */
    public static $dirMap = array(
        'clients/base/api/',
        "data/visibility/",
        "data/Relationships/",
        "data/duplicatecheck/",
        'include/api/',
        "include/CalendarEvents/",
        "include/SugarSearchEngine/",
        "include/",
        "modules/Mailer/",
        'modules/Calendar/',
    );

    /**
     * Directories to exclude form mapping
     * @var array
     */
    public static $exclude = array(
        'cache',
        'custom/history',
        '.idea',
        'custom/blowfish',
        'custom/Extension',
        'custom/backup',
        'custom/modulebuilder',
        'tests',
        'examples',
        'docs',
        'vendor/log4php',
        'upload',
        'portal',
        'vendor/HTMLPurifier',
        'vendor/PHPMailer',
        'vendor/reCaptcha',
        'vendor/ytree',
        'vendor/pclzip',
        'vendor/nusoap',
        'vendor/bin',
    );

    /**
     * Extensions to include in mapping
     * @var array
     */
    public static $exts = array(
        'php',
        'tpl',
        'html',
        'js',
        'override',
        'gif',
        'png',
        'jpg',
        'tif',
        'bmp',
        'ico',
        'css',
        'xml',
        'hbs',
        'less',
    );

    /**
     * File map
     * @var array
     */
    public static $filemap = array();
    public static $memmap = array();

    /**
     * Copy of extension map
     * @var array
     */
    public static $extensions = array();

    /**
     * @var boolean Developer mode flag
     */
    public static $devMode = false;

    /**
     * @var array List of composer paths
     */
    protected static $composerPaths = array(
        'include_paths' => 'vendor/composer/include_paths.php',
        'autoload_namespaces' => 'vendor/composer/autoload_namespaces.php',
        'autoload_psr4' => 'vendor/composer/autoload_psr4.php',
        'autoload_classmap' => 'vendor/composer/autoload_classmap.php',
    );

    /**
     * Initialize the loader
     */
    public static function init()
    {
        $config = SugarConfig::getInstance();

        /*
         * When development mode is enabled, we bypass the usage
         * of the filemap and build the classmap dynamically on
         * every page load. We drop both cache file to make sure
         * when devMode is disabled again that the system is
         * properly initialized again withour the need for
         * running a QuickRepairRebuild.
         */
        self::$devMode = $config->get('developerMode', false);
        if (self::$devMode) {
            @unlink(sugar_cached(self::CACHE_FILE));
            @unlink(sugar_cached(self::CLASS_CACHE_FILE));
        }

        // Extensions included from config
        $exts = $config->get('autoloader.exts');
        if (is_array($exts)) {
            self::$exts += $exts;
        }

        // Excludes from config
        $exclude = $config->get('autoloader.exclude');
        if (is_array($exclude)) {
            self::$exclude += $exclude;
        }

        // Create file map
        self::loadFileMap();

        // Composer integration
        self::loadComposerIncludePaths();
        self::loadComposerPsr4();
        self::loadComposerPsr0();

        // Build class map (implicitly includes Composer's classmap)
        self::loadClassMap();

        // Register ourself (prepend)
        self::registerAutoload(true);

        // Load extensions
        self::loadExts();
    }

    /**
     * Load Composer generated include paths
     */
    public static function loadComposerIncludePaths()
    {
        $includePaths = self::getIncludeReturn(self::$composerPaths['include_paths']);
        array_push($includePaths, get_include_path());
        set_include_path(join(PATH_SEPARATOR, $includePaths));
    }

    /**
     * Load Composer generated PSR4 namespace mappings
     */
    public static function loadComposerPsr4()
    {
        $map = self::getIncludeReturn(self::$composerPaths['autoload_psr4']);
        foreach ($map as $namespace => $paths) {
            if (is_array($paths)) {
                foreach ($paths as $path) {
                    $path = self::normalizeFilePath($path);
                    self::addNamespace($namespace, $path, 'psr4');
                }
            } else {
                $path = self::normalizeFilePath($paths);
                self::addNamespace($namespace, $path, 'psr4');
            }
        }
    }

    /**
     * Load Composer generated PSR0 namespace mappings
     */
    public static function loadComposerPsr0()
    {
        $map = self::getIncludeReturn(self::$composerPaths['autoload_namespaces']);
        foreach ($map as $namespace => $paths) {
            if (is_array($paths)) {
                foreach ($paths as $path) {
                    $path = self::normalizeFilePath($path);
                    self::addNamespace($namespace, $path, 'psr0');
                }
            } else {
                $path = self::normalizeFilePath($paths);
                self::addNamespace($namespace, $path, 'psr0');
            }
        }
    }

    /**
     * Get Composer generated class map
     * @return array
     */
    public static function getComposerClassMap()
    {
        $classMap = self::getIncludeReturn(self::$composerPaths['autoload_classmap']);
        return array_map(array('SugarAutoLoader', 'normalizeFilePath'), $classMap);
    }

    /**
     * Helper function returning an include file
     * @param string $file Filename to include
     * @param mixed $default Default value to return if file is not found
     * @return mixed
     */
    protected static function getIncludeReturn($file, $default = array())
    {
        if (self::fileExists($file)) {
            $return = @include $file;
        }
        return (!isset($return) ? $default : $return);
    }

    /**
     * Register SugarAutoLoader
     * @param boolean $prepend Prepend on top of spl_autoload stack
     */
    public static function registerAutoload($prepend = true)
    {
        spl_autoload_register(array('SugarAutoLoader', 'autoload'), true, $prepend);
    }

	/**
	 * Load a class
	 * @param string $class Class name
	 * @return boolean Success?
	 */
    public static function autoload($class)
	{
        // work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731
        $class = ltrim($class, '\\');

        $uclass = ucfirst($class);
        if (!empty(self::$noAutoLoad[$class])) {
            return false;
        }

        // try known classes
        if (isset(self::$classMap[$uclass])) {
            if (self::$classMap[$uclass]) {
                // No need for a file_exists, if it is in the map we have found it before
                require_once self::$classMap[$uclass];
                return true;
            }
            return false;
        }

        // try namespaces
        if (false !== strpos($class, '\\')) {
            if ($file = self::getFilenameForFQCN($class)) {
                if (self::load($file)) {
                    self::$classMap[$class] = $file;
                    self::$classMapDirty = true;
                    return true;
                }
            }
            self::$classMap[$class] = false;
            self::$classMapDirty = true;
            return false;
        }

        if (empty(self::$moduleMap)) {
            if (isset($GLOBALS['beanFiles'])) {
                self::$moduleMap = $GLOBALS['beanFiles'];
            } else {
                include('include/modules.php');
                self::$moduleMap = $beanFiles;
            }
        }

        // Try known modules
        if (!empty(self::$moduleMap[$class])) {
            require_once self::$moduleMap[$class];
            return true;
        }

		if (strncmp('HTMLPurifier', $class, 12) == 0) {
			return HTMLPurifier_Bootstrap::autoload($class);
		}

	    // Split on _, capitalize elements and make a path
	    // foo_bar -> Foo/Bar.
	    $class_file = join('/', array_map('ucfirst', explode('_', $class)));

		// Try known prefixes
		foreach(self::$prefixMap as $prefix => $dir) {
		    if(strncasecmp($prefix, $class, strlen($prefix)) === 0) {
		        if($file = self::requireWithCustom("{$dir}$class_file.php")) {
		            self::$classMap[$uclass] = $file;
		            self::$classMapDirty = true;
		            return true;
		        } else {
		            break;
		        }
		    }
		}

		// Special cases
		// Special case because lookup goes to $_REQUEST['module']
		if($file = self::getFilenameForViewClass($class)) {
			self::$classMap[$uclass] = $file;
			self::$classMapDirty = true;
			return true;
		}
		// Special case because widget name can be lowercased
		if($file = self::getFilenameForSugarWidget($class)) {
			self::$classMap[$uclass] = $file;
			self::$classMapDirty = true;
			return true;
		}
		// Special case because it checks by ending in Layout
		if($file = self::getFilenameForLayoutClass($class)) {
			self::$classMap[$uclass] = $file;
			self::$classMapDirty = true;
			return true;
		}
        if($file = self::getFilenameForExpressionClass($class)) {
            self::$classMap[$uclass] = $file;
            self::$classMapDirty = true;
            return true;
        }

		// Try known dirs
		foreach(self::$dirMap as $dir) {
		    // include/Class.php
		    if($file = self::requireWithCustom("{$dir}$class_file.php")) {
		        self::$classMap[$uclass] = $file;
		        self::$classMapDirty = true;
		        return true;
		    }
		    // include/Class/Class.php
		    // Note here we don't use $class_file since using path twice would not make sense:
		    // Foo/Bar/Foo/Bar.php vs. Foo_Bar/Foo_Bar.php
			if($file = self::requireWithCustom("{$dir}$class/$class.php")) {
		        self::$classMap[$uclass] = $file;
		        self::$classMapDirty = true;
		        return true;
		    }
		    // try include/Foo_Bar.php as a last resort
			if($file = self::requireWithCustom("{$dir}$class.php")) {
		        self::$classMap[$uclass] = $file;
		        self::$classMapDirty = true;
		        return true;
		    }
		}

        self::$classMap[$uclass] = false;
        self::$classMapDirty = true;
        return false;
	}

    /**
     * Return filename for given Fully Qualified Class Name
     *
     * @param string $class FQCN without leading backslash
     * @return string|false
     */
    public static function getFilenameForFQCN($class)
    {
        // PSR-4 has precendence
        if ($file = self::getFileNamePsr4($class)) {
            return $file;
        }

        return self::getFileNamePsr0($class);
    }

    /**
     * PSR-0 support http://www.php-fig.org/psr/psr-0/
     *
     * @param string $class Fully Qualified Class Name
     * @return string|false
     */
    public static function getFileNamePsr0($class)
    {
        foreach (self::$namespaceMap as $namespace => $paths) {
            foreach ($paths as $path) {
                if (strpos($class, $namespace) === 0) {
                    $path = empty($path) ? '' : $path . '/';
                    if (false !== $pos = strrpos($class, '\\')) {
                        $path .= str_replace('\\', '/', substr($class, 0, $pos)) . '/';
                        $path .= str_replace('_', '/', substr($class, $pos + 1)) . '.php';
                    } else {
                        $path .= str_replace('_', '/', $class) . '.php';
                    }
                    if (self::fileExists($path)) {
                        return $path;
                    }
                }
            }
        }
        return false;
    }

    /**
     * PSR-4 support http://www.php-fig.org/psr/psr-4/
     *
     * @param string $class Fully Qualified Class Name
     * @return mixed(string|boolean)
     */
    public static function getFileNamePsr4($class)
    {
        foreach (self::$namespaceMapPsr4 as $prefix => $paths) {
            foreach ($paths as $path) {
                if (strpos($class, $prefix) === 0) {
                    $path = empty($path) ? '' : $path . '/';
                    $path .= str_replace('\\', '/', str_replace($prefix, '', $class)) . '.php';
                    if (self::fileExists($path)) {
                        return $path;
                    }
                }
            }
        }
        return false;
    }

	/**
	 * Load layout class from include/MetaDataManager/layouts
	 * @param string $class
	 * @return string|false
	 */
    protected static function getFilenameForLayoutClass($class)
    {
        if(substr($class, -6) == "Layout") {
            return self::requireWithCustom("include/MetaDataManager/layouts/$class.php");
        }
        return false;
    }

    /**
	 * Add directory for loading classes
	 * Directory should include trailing /
	 * @param string $dir
	 */
	public static function addDirectory($dir)
	{
	    self::$dirMap[] = $dir;
	}

    /**
     * Add namespace prefix directory mapping
     *
     * @param string $prefix
     * @param string $dir
     * @param string $type `psr0` (default) or `psr4`
     */
    public static function addNamespace($prefix, $dir, $type = 'psr0')
    {
        // select which map to use
        $map = ($type === 'psr4') ? 'namespaceMapPsr4' : 'namespaceMap';

        // enforce trailing \
        $prefix = rtrim($prefix, '\\') . '\\';

        // remove trailing / and normalize path
        $dir = rtrim(self::normalizeFilePath($dir), '/');

        // use a list of paths per prefix
        self::${$map}[$prefix][] = $dir;

        // The order of self::$namespace is important because the first match
        // will win. When registering new namespace dynamically we need to make
        // sure this array is ordered from more to less specific.

        uksort(self::${$map}, function ($val1, $val2) {
            $level1 = substr_count($val1, '\\');
            $level2 = substr_count($val2, '\\');
            if ($level1 > $level2) {
                return -1;
            } elseif ($level1 < $level2) {
                return 1;
            } else {
                // if levels are the same, sort alphabetically for predictable result
                return strcasecmp($val1, $val2);
            }
        });
    }

	/**
	 * Add directory for loading classes by prefix
	 * Directory should include trailing /
	 * @param string $prefix
	 * @param string $dir
	 */
	public static function addPrefixDirectory($prefix, $dir)
	{
	    self::$prefixMap[$prefix] = $dir;
	}

	protected static function getFilenameForViewClass($class)
    {
        $module = false;
        if (!empty($_REQUEST['module']) && substr($class, 0, strlen($_REQUEST['module'])) === $_REQUEST['module'])
        {
            //This is a module view
            $module = $_REQUEST['module'];
            $class = substr($class, strlen($module));
        }

        if (substr($class, 0, 4) == "View")
        {
            $view = strtolower(substr($class, 4));
            if ($module)
            {
                return self::requireWithCustom("modules/$module/views/view.$view.php");
            } else {
                return self::requireWithCustom("include/MVC/View/views/view.$view.php");
            }
        }
        return false;
    }

    /**
     * getFilenameForSugarWidget
     *
     * This method attempts to autoload classes starting with name "SugarWidget".  It first checks for the file
     * in custom/include/generic/SugarWidgets directory and if not found defaults to include/generic/SugarWidgets.
     * This method is used so that we can easily customize and extend these SugarWidget classes.
     *
     * Can not be served by prefixMap because of the lowercasing in class names.
     *
     * @static
     * @param $class String name of the class to load
     * @return String file of the SugarWidget class; false if none found
     */
    protected static function getFilenameForSugarWidget($class)
    {
        //Only bother to check if the class name starts with SugarWidget
        if(strpos($class, 'SugarWidgetField') !== false) {
            //We need to lowercase the portion after SugarWidgetField
            $name = substr($class, 16);
            if(empty($name)) {
                return false;
            }
            $class = 'SugarWidgetField' . strtolower($name);
            return self::requireWithCustom("include/generic/SugarWidgets/{$class}.php");
        }
        return false;
    }

    /**
     * Load file if exists
     * @param string $file
     * @return boolean True if file was loaded
     */
    public static function load($file)
    {
        if(self::fileExists($file)) {
            require_once $file;
            return true;
        }
        return false;
    }

    /**
     * Load file either from custom, if exists, or from core
     * @param string $file filename
     * @param bool $both Do we want both?
     * @return was any file loaded?
     */
    public static function requireWithCustom($file, $both = false)
    {
        if(self::fileExists("custom/$file")) {
            if($both) {
                // when loading both, core file goes first so custom can override it
                // however we check for custom first and if $both not set load only it
                if(self::fileExists($file)) {
                    require_once $file;
                }
            }
            require_once "custom/$file";
            return "custom/$file";
        } else {
            if(self::fileExists($file)) {
                require_once $file;
                return $file;
            }
        }
        return false;
    }

    /**
     * Get list of existing files and their customizations.
     * @param ... $files
     * @return array Existing files and customizations. Customizations go after files.
     */
    public static function existing()
    {
        $files = func_get_args();
        $out = array();
        foreach($files as $file) {
            if(empty($file)) continue;
            if(is_array($file)) {
                $out += call_user_func_array(array("SugarAutoLoader", "existing"), $file);
                continue;
            }
            if(self::fileExists($file)) {
                $out[] = $file;
            }
        }
        return $out;
    }

    /**
     * Get list of existing files and their customizations.
     * @param ... $files
     * @return array Existing files and customizations. Customizations go after files.
     */
    public static function existingCustom()
    {
        $files = func_get_args();
        $out = array();
        foreach($files as $file) {
            if(empty($file)) continue;
            if(is_array($file)) {
                $out += call_user_func_array(array("SugarAutoLoader", "existingCustom"), $file);
                continue;
            }
            if(self::fileExists($file)) {
                $out[] = $file;
            }
            if(substr($file, 0, 7) != 'custom/' && self::fileExists("custom/$file")) {
                $out[] = "custom/$file";
            }
        }
        return $out;
    }

    /**
     * Get customized file or core file.
     * Returns only the last existing variant, custom if exists
     * @param ... $files
     * @return string|null Last existing file out of given arguments
     */
    public static function existingCustomOne()
    {
        $files = func_get_args();
        $out = call_user_func_array(array("SugarAutoLoader", "existingCustom"), $files);
        if(empty($out)) {
            return null;
        } else {
            return array_pop($out);
        }
    }

    /**
     * Lookup filename in a list of paths. Paths are checked with and without custom/
     * @param array $paths
     * @param string $file
     * @return string|bool Filename found or false
     */
    public static function lookupFile($paths, $file)
    {
        foreach($paths as $path) {
            $fullname = "$path/$file";
            if(self::fileExists("custom/$fullname")) {
                return "custom/$fullname";
            }
            if(self::fileExists($fullname)) {
                return $fullname;
            }
        }
        return false;
    }

    /**
     * getFilenameForExpressionClass
     *
     * Used to autoload classes that end in "Expression". It will check in all directories found in
     * custom/include/Expressions/Expression and include/Expressions/Expression .
     * This method is allows for easy loading of arbitrary expression classes by the SugarLogic Expression parser.
     *
     * @static
     * @param $class String name of the class to load
     * @return String file of the Expression class; false if none found
     */
    protected static function getFilenameForExpressionClass($class)
    {
        if(substr($class, -10) == 'Expression') {
            if($file = self::requireWithCustom("include/Expressions/Expression/{$class}.php")) {
                return $file;
            }

            $types = array("Boolean", "Date", "Enum", "Generic", "Numeric", "Relationship", "String", "Time");

            foreach($types as $type) {
                if($file = self::requireWithCustom("include/Expressions/Expression/{$type}/{$class}.php")) {
                    return $file;
                }
            }
        }
        return false;
    }


    /**
     * Load all classes in self::$classMap
     */
    public static function loadAll()
    {
        foreach (self::$classMap as $class => $file) {
            require_once $file;
        }
        if (isset($GLOBALS['beanFiles'])) {
            $files = $GLOBALS['beanFiles'];
        } else {
            include 'include/modules.php';
            $files = $beanList;
        }
        foreach ($files as $class => $file) {
            require_once $file;
        }
    }

	/**
	 * Get viewdefs file name using the following logic:
	 * 1. Check custom/module/metadata/$varname.php
	 * 2. If not there, check metafiles.php
	 * 3. If still not found, use module/metadata/$varname.php
	 * This is used for Studio-enabled definitions. Only one file is loaded
	 * because Studio should be able to delete fields.
	 * @param string $module
	 * @param string $varname Name of the vardef file (listviewdef, etc.) - no .php
	 * @return string|null Suitable metadata file or null
	 */
	public static function loadWithMetafiles($module, $varname)
	{
	    $vardef = self::existingCustomOne("modules/{$module}/metadata/{$varname}.php");
	    if(!empty($vardef) && substr($vardef, 0, 7) == "custom/") {
	        // custom goes first, because this is how Studio overrides defaults
	        return $vardef;
	    }
	    // otherwise check metadata
	    global $metafiles;
	    if(!isset($metafiles[$module])) {
	        $meta = self::existingCustomOne('modules/'.$module.'/metadata/metafiles.php');
    	    if($meta) {
    	    	require $meta;
    	    }
	    }
	    if(!empty($metafiles[$module][$varname])) {
	        $defs = self::existing($metafiles[$module][$varname], $vardef);
	    } else {
	        $defs = self::existing($vardef);
	    }
	    if(!$defs) {
	        return null;
	    } else {
	        return $defs[0];
	    }
	}

	/**
     * Load search fields
     * Search fields are loaded differently since they are not Studio metadata file,
     * so they are combined instead of being overloaded.
     * NOTE: unlike generic loadWithMetafiles, this one returns defs, not filenames
     * Also note that even though $module is given, the defs are not in $searchFields but in $searchFields[$module]
     * for BC reasons.
	 * @param string $module
	 * @return array searchFields def
	 */
	public static function loadSearchFields($module)
	{
		// load metadata first
		global $metafiles;
		if(!isset($metafiles[$module])) {
			$meta = self::existingCustomOne('modules/'.$module.'/metadata/metafiles.php');
			if($meta) {
				require $meta;
			}
		}
        // Then get all files that are revevant
		if(!empty($metafiles[$module]['searchfields'])) {
			$defs = $metafiles[$module]['searchfields'];
		} else {
			$defs = "modules/$module/metadata/SearchFields.php";
		}

		foreach(self::existingCustom($defs) as $file) {
		    require $file;
		}
		if(empty($searchFields)) {
		    return array();
		}
		return $searchFields;
	}

	/**
	 * Load popupdefs metadata file
	 * Allows to override 'popupdefs' with $metadata variable
     * NOTE: unlike generic loadWithMetafiles, this one returns defs, not filenames
	 * @param string $module
	 * @param string $metadata metadata name override
	 * @return array popup defs data or NULL
	 */
	public static function loadPopupMeta($module, $metadata = null)
	{
	    $defs = null;
	    if($metadata == 'undefined' || strpos($metadata, "..") !== false) {
	        $metadata = null;
	    }
	    if(!empty($metadata)) {
	    	$defs = SugarAutoLoader::loadWithMetafiles($module, $metadata);
	    }

	    if(!$defs) {
	    	$defs = SugarAutoLoader::loadWithMetafiles($module, 'popupdefs');
	    }
        if($defs) {
            require $defs;
            return $popupMeta;
        }
        return array();
	}

	/**
	 * Get metadata file for an extension
	 * see extensions.php for the list
	 * @param string $extname Extension name
	 * @param string $module Module to apply to
	 * @return boolean|string File to load, false if none
	 */
	public static function loadExtension($extname, $module = "application")
	{
	    if(empty(self::$extensions[$extname])) return false;
	    $ext = self::$extensions[$extname];
	    if(empty($ext['file']) || empty($ext['extdir'])) {
	        // custom rebuilds, can't handle
	        return false;
	    }
	    if(isset($ext["module"])) {
	        $module = $ext["module"];
	    }
	    if($module == "application") {
	        $file = "custom/application/Ext/{$ext["extdir"]}/{$ext["file"]}";
	    } else {
	        $file = "custom/modules/{$module}/Ext/{$ext["extdir"]}/{$ext["file"]}";
	    }
	    if(self::fileExists($file)) {
	        return $file;
	    }
        return false;
	}

    /**
     * Check if file exists in the cache
     * @param string $filename
     * @return boolean
     */
    public static function fileExists($filename)
    {
        $filename = self::normalizeFilePath($filename);
        
        // See if this filename would have been skipped by the cache creator. This
        // addresses situations like module loader that call sugar_* file functions
        // that use the autoloader on files that are in cache, etc.
        $excluded = false;
        foreach (self::$exclude as $path) {
            if (strpos($filename, $path) === 0) {
                $excluded = true;
                break;
            }
        }

        if ($excluded) {
            // This is a filename that would have been skipped, so check the file
            // system for existence
            return file_exists($filename);
        }
        
        if(isset(self::$memmap[$filename])) {
            return (bool)self::$memmap[$filename];
        }

        // Remember the file_exist calls in dev mode directly
        // without traversing the filemap as it's empty. This
        // will safe us multiple calls to file_exist within
        // the same page.
        if (self::$devMode) {
            self::$memmap[$filename] = file_exists($filename);
            return (bool)self::$memmap[$filename];
        }

        $parts = explode('/', $filename);
        $data = self::$filemap;
        foreach($parts as $part) {
            if(empty($part)) continue; // allow sequences of /s
            if(!isset($data[$part])) {
                self::$memmap[$filename] = false;
                return false;
            }
            $data = $data[$part];
        }
        if($data || $data == array()) {
            self::$memmap[$filename] = true;
            return true;
        }
        self::$memmap[$filename] = false;
        return false;
    }

    /**
     * Get all files in directory from cache
     * @param string $dir
     * @param bool $get_dirs Get directories and not files
     * @param string $extension Get only files with given extension
     * @param boolean $recursive Scan directory recursively
     * @return array List of files
     */
    public static function getDirFiles($dir, $get_dirs = false, $extension = null, $recursive = false)
    {
        // In development mode we don't have the filemap available. To avoid
        // full rebuilds on every page load, only load what we need at this
        // point.
        if (self::$devMode) {
            $data = self::scanSubDir($dir);
        } else {
            if (empty(self::$filemap)) {
                self::init();
            }
            $data = self::$filemap;
        }

        // remove leading . if present
        $extension = ltrim($extension, ".");
        $dir = rtrim($dir, "/");
        $parts = explode('/', $dir);
        foreach ($parts as $part) {
            if (empty($part)) {
                continue; // allow sequences of /s
            }
            if (!isset($data[$part])) {
        		return array();
        	}
        	$data = $data[$part];
        }

        if (!is_array($data)) {
            return array();
        }

        return self::flatten($dir, $data, $get_dirs, $extension, $recursive);
    }

    /**
     * Flattens the result of self::getDirFiles()
     *
     * @param string $dir Base directory
     * @param array $data Tree data
     * @param boolean $get_dirs
     * @param string $extension Filter files by extension
     * @param boolean $recursive Use data from subdirectories
     *
     * @return array Flattened data
     */
    protected function flatten($dir, array $data, $get_dirs, $extension, $recursive)
    {
        $result = array();
        foreach ($data as $file => $nodes) {
            // check extension if given
            if (!empty($extension) && pathinfo($file, PATHINFO_EXTENSION) != $extension) {
                continue;
            }
            $path = $dir . '/' . $file;
            // get dirs or files depending on $get_dirs
            if (is_array($nodes) == $get_dirs) {
                $result[] = $path;
            }
            if ($recursive && is_array($nodes)) {
                $result = array_merge(
                    $result,
                    self::flatten($path, $nodes, $get_dirs, $extension, $recursive)
                );
            }
        }

        return $result;
    }

    /**
     * Get list of files in this dir and custom duplicate of it
     * @param string $dir
     * @param bool $get_dirs Get directories and not files
     * @return array
     */
    public static function getFilesCustom($dir, $get_dirs = false, $extension = null)
    {
        return array_merge(self::getDirFiles($dir, $get_dirs, $extension), self::getDirFiles("custom/$dir", $get_dirs, $extension));
    }


    /**
     * Build file cache
     */
	public static function buildCache()
	{
        $data = self::scanDir("");
        write_array_to_file("existing_files", $data, sugar_cached(self::CACHE_FILE));
        self::$filemap = $data;
        self::$memmap = array();
        // Rebuild the class cache so that it can find any new classes in the file map
        self::buildClassCache();
	}

    /**
     * Load cached file map
     */
    public static function loadFileMap()
    {
        $existing_files = array();

        /*
         * In development mode we can skip loading/building
         * the file_map as we will revert back to pure file_exists
         * and not make use of this mapping.
         */
        if (!self::$devMode) {
            @include sugar_cached(self::CACHE_FILE);
            if (empty($existing_files)) {
                // oops, something happened to cache
                // try to rebuild
                self::buildCache();
                @include sugar_cached(self::CACHE_FILE);
            }
        }

        self::$filemap = $existing_files;
        self::$memmap = array();
    }

    /**
     * Build class map cache
     */
    public static function buildClassCache()
    {
        $class_map = array();
        foreach(self::existingCustom('include/utils/class_map.php') as $file) {
            require $file;
        }

        // add composer classmap
        $class_map = array_merge($class_map, self::getComposerClassMap());

        // Don't save to disk in development mode as the map will be ignored
        // and its content will not be incremental.
        if (!self::$devMode) {
            write_array_to_file("class_map", $class_map, sugar_cached(self::CLASS_CACHE_FILE));
        }

        self::$classMap = $class_map;
        self::$classMapDirty = false;
    }

    /**
     * Load cached class map
     */
    public static function loadClassMap()
    {
        $class_map = array();

        // in development mode we start with a clean slate
        if (!self::$devMode) {
            @include sugar_cached(self::CLASS_CACHE_FILE);
        }

        if(empty($class_map)) {
            // oops, something happened to cache
            // try to rebuild
            self::buildClassCache();
        } else {
            self::$classMap = $class_map;
            self::$classMapDirty = false;
        }
    }

	/**
	 * Load extensions map
	 */
	protected static function loadExts()
	{
	    include "ModuleInstall/extensions.php";
	    self::$extensions = $extensions;
	}

	/**
	 * Add filename to list of existing files
	 * @param string $filename
	 * @param bool $save should we save it to file?
	 * @param bool $dir should it be empty directory?
	 */
	public static function addToMap($filename, $save = true, $dir = false)
	{
        // Normalize filename
        $filename = self::normalizeFilePath($filename);

	    if(self::fileExists($filename))
	        return;
        foreach(self::$exclude as $exclude_pattern) {
            if(substr($filename, 0, strlen($exclude_pattern)) == $exclude_pattern) {
                return;
            }
        }

        self::$memmap[$filename] = 1;

        $parts = explode('/', $filename);
	    $filename = array_pop($parts);
	    $data =& self::$filemap;
	    foreach($parts as $part) {
            if(empty($part)) continue; // allow sequences of /s
	        if(!isset($data[$part])) {
                $data[$part] = array();
	        }
	        $data =& $data[$part];
	    }
	    if(!is_array($data)) {
	        $data = array();
	    }
	    $data[$filename] = $dir?array():1;
	    if($save) {
	        write_array_to_file("existing_files", self::$filemap, sugar_cached(self::CACHE_FILE));
	    }
	}

	/**
	 * Delete file from the map
	 * Mainly for use in tests
	 * @param string $filename
	 * @param bool $save should we save it to file?
	 */
	public static function delFromMap($filename, $save = true)
	{
	    // Normalize directory separators
        $filename = self::normalizeFilePath($filename);

	    // we have to reset here since we could delete a directory
        // and memmap is not hierarchical. It may be a performance hit
        //
	    self::$memmap = array();
        $parts = explode('/', $filename);
	    $filename = array_pop($parts);
	    $data =& self::$filemap;
	    foreach($parts as $part) {
            if(empty($part)) continue; // allow sequences of /s
	        if(!isset($data[$part])) {
	    	  return;
	    	}
	    	$data =& $data[$part];
	    }
	    unset($data[$filename]);
	    if($save) {
	        write_array_to_file("existing_files", self::$filemap, sugar_cached(self::CACHE_FILE));
	    }
	}

    /**
     * Scan directory and build the list of files it contains
     * @param string $path
     * @return array Files data
     */
    public static function scanDir($path)
    {
        $path = rtrim($path, '/');
        if (in_array($path, self::$exclude) || !file_exists("./".$path)) {
            return array();
        }

        $iter = new DirectoryIterator("./".$path);
        $data = array();
        foreach ($iter as $item) {
            if ($item->isDot()) {
                continue;
            }
            $filename = $item->getFilename();
            if ($item->isDir()) {
                $filepath = ($path === "") ? $filename : $path . '/' . $filename;
                $data[$filename] = self::scanDir($filepath);
            } else {
                if (!in_array(pathinfo($filename, PATHINFO_EXTENSION), self::$exts)) {
                    continue;
                }
                $data[$filename] = 1;
            }
        }

        return $data;
    }

    /**
     * This method is equivalent to `self::scanDir`, but allows to scan
     * a specific sub directory (leaf) only while still returning the
     * same structure as returned by `self::scanDir` from the base dir.
     *
     * This is an internal function and should only be called when
     * using developer mode.
     *
     * @param string $path
     * @return array Files data
     */
    protected static function scanSubDir($path)
    {
        $data = self::scanDir($path);

        // append base path structure
        $subDirs = array_reverse(explode('/', $path));
        $data = array_reduce($subDirs, function ($c, $i) use ($data) {
            return array($i => (empty($c) ? $data : $c));
        });

        return $data;
    }

    /**
     * Get custom class name if that exists or original one if not
     * @param string $className Class name, legacy or FQCN
     * @param boolean $autoload Try to autoload the custom class, always true
     *      when a namespaced class name is passed in.
     * @return string Classname
     */
    public static function customClass($className, $autoload = false)
    {
        if (strpos($className, '\\') !== false) {
            $customClass = self::getCustomClassFQCN($className);
            $autoload = true;
        } else {
            $customClass = 'Custom'.$className;
        }

        if ($customClass && class_exists($customClass, $autoload)) {
            return $customClass;
        }

        return $className;
    }

    /**
     * Get custom fully qualified class name, return false if not able
     * to transform the given class name into its custom counterpart.
     * Will also return false if given class name is already in custom
     * format.
     * @param string $className Fully qualified class name
     * @return string|false
     */
    public static function getCustomClassFQCN($className)
    {
        $customBase = self::NS_ROOT . 'custom\\';
        if (strpos($className, self::NS_ROOT) === 0 && strpos($className, $customBase) === false) {
            return str_replace(self::NS_ROOT, $customBase, $className);
        }
        return false;
    }

	/**
	 * Unlink and delete from map
	 * To use mainly for tests
	 * @param string $filename
	 * @param bool $save Save map to file?
	 * @return bool Success?
	 */
	public static function unlink($filename, $save = false)
	{
	    self::delFromMap($filename, $save);
	    unlink($filename);
	}

	/**
	 * Create empty file and add to map
	 * To use mainly for tests
	 * @param string $filename
	 * @param bool $save Save map to file?
	 * @return bool Success?
	 */
	public static function touch($filename, $save = false)
	{
	    if(sugar_touch($filename)) {
	        self::addToMap($filename, $save);
	        return true;
	    }
	    return false;
	}

	/**
	 * Put data to file and add to map
	 * To use mainly for tests
	 * @param string $filename
	 * @param bool $save Save map to file?
	 * @return bool Success?
	 */
	public static function put($filename, $data, $save = false)
	{
	    if(file_put_contents($filename, $data) !== false) {
	        self::addToMap($filename, $save);
	        return true;
	    }
	    return false;
	}

	/**
	 * Ensure the directory exists
	 * @param string $dir
	 * @return boolean
	 */
	public static function ensureDir($dir)
	{
	    if(self::fileExists($dir)) {
	        return true;
	    }
	    if(sugar_mkdir($dir, null, true)) {
	        self::addToMap($dir, true, true);
	        return true;
	    }
	    return false;
	}

	/**
	 * Save the file map to disk
	 */
	public static function saveMap()
	{
	    write_array_to_file("existing_files", self::$filemap, sugar_cached(self::CACHE_FILE));
	}

    /**
     * Save the file map to disk
     */
    public static function saveClassMap()
    {
        if (!self::$devMode && self::$classMapDirty && !empty(self::$classMap)) {
            write_array_to_file("class_map", self::$classMap, sugar_cached(self::CLASS_CACHE_FILE));
            self::$classMapDirty = false;
        }
    }

    /**
     * Cleans up a filepath, normalizing path separators and removing extras
     *
     * @param string $filename The name of the file to work on
     * @return string
     */
    public static function normalizeFilePath($filename)
    {
        // Normalize directory separators
        if(DIRECTORY_SEPARATOR != '/') {
            $filename = str_replace(DIRECTORY_SEPARATOR, "/", $filename);
        }

        // Remove repeated separators
        $filename = preg_replace('#(/)(\1+)#', '/', $filename);

        // Remove base dir - Composer always has absolute paths.
        $filename = str_replace(SUGAR_BASE_DIR . "/", "", $filename);

        return $filename;
    }
}
