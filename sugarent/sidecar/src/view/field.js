/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {

    /**
     * SugarField widget. A field widget is a low level field widget. Some examples of fields are
     * text boxes, date pickers, drop down menus.
     *
     * ##Creating a SugarField
     * SugarCRM allows for customized "fields" which are visual representations of a type of data (e.g. url would
     * be displayed as a hyperlink).
     *
     * ###Anatomy of a SugarField
     * Field files reside in the **`sugarcrm/clients/base/fields/{field_type}`** folder.
     *
     * Inside the {field_type} directory is a set of files that define templates for different views and field controller.
     * A typical directory structure will look like the following:
     * <pre>
     * clients
     * |- base
     *    |- bool
     *       |- bool.js
     *       |- detail.hbs
     *       |- edit.hbs
     *       |- list.hbs
     *    |- int
     *       ...
     *    |- text
     *       ...
     * |- portal
     *    |- portal specific overrides
     * |- mobile
     *    |- mobile specific overrides
     * </pre>
     * **`[sugarFieldType].js`** files are optional.
     * Sometimes a SugarField needs to do more than just display a simple input element, other times input elements
     * need additional data such as drop down menu choices. To support advanced functionality, just add your additional
     * controller logic to **`[sugarFieldType].js`** javascript file where sugarFieldType is the type of the SugarField.
     * Example for `bool.js` controller:
     * <pre><code>
     * ({
     *    events: {
     *         handler: function() {
     *             // Actions
     *         }
     *    },
     *
     *    initialize: function(options) {
     *       app.view.Field.prototype.initialize(options);
     *       // Your constructor code here follows...
     *    },
     *
     *    unformat: function(value) {
     *        value = this.el.children[0].children[1].checked ? "1" : "0";
     *        return value;
     *    },
     *    format: function(value) {
     *        value = (value == "1") ? true : false;
     *        return value;
     *    }
     * })
     * </code></pre>
     *
     * **`.hbs`** files contain your templates corresponding to the type of {@link View.View} the field is to be displayed on.
     * Sugar uses Handlebars.js as its client side template of choice. At this time no other templating engines are
     * supported. Sample:
     * <pre><code>
     * &lt;span name="{{name}}"&gt;{{value}}&lt;/span&gt;
     * </code></pre>
     *
     * These files will be used by the metadata manager to generate metadata for your SugarFields and pass them onto the
     * Sugar JavaScript client.
     *
     * </pre></code>
     *
     * ####SugarField Template Values
     * TODO:
     *
     *
     * @class View.Field
     * @alias SUGAR.App.view.Field
     * @extends View.Component
     */
    app.view.Field = app.view.Component.extend({

        /**
         * HTML tag of the field.
         * @property {String}
         */
        fieldTag: "input",

        /**
         * TODO: add docs (describe options, see Component class for details)
         * @param options
         */
        initialize: function(options) {
            app.plugins.attach(this, "field");
            app.view.Component.prototype.initialize.call(this, options);

            /**
             * ID of the field (autogenerated).
             * @property {Number}
             * @member View.Field
             */
            this.sfId = options.sfId;

            /**
             * Reference to the view this field is attached to.
             * @property {View.View}
             * @member View.Field
             */
            this.view = options.view;

            /**
             * Field name.
             * @property {String}
             * @member View.Field
             */
            this.name = this.options.def.name;

            /**
             * Widget type (text, bool, int, etc.).
             * @property {String}
             * @member View.Field
             */
            this.type = this.options.def.type;

            if (this.model && this.model.fields) {
                // Set module field definition (vardef)
                var clonedVarDef = _.clone(this.model.fields[this.name]);
                /**
                 * Field metadata definition (vardef + viewdef).
                 *
                 * Viewdef are copied over vardef.
                 * @property {Object}
                 * @member View.Field
                 */
                // Beware of shallow clone! We assume here that vardef object has only primitive types
                this.def = clonedVarDef ? _.extend(clonedVarDef, options.def) : options.def;
            }
            else {
                this.def = this.options.def;
            }

            /**
             * i18n-ed field label.
             * @property {String}
             * @member View.Field
             */
            this.label = app.lang.get(this.def.label || this.def.vname || this.name, this.module);

            /**
             * Compiled template.
             * @property {Function}
             * @member View.Field
             */
            this.template = app.template.empty;

            // Bind validation error event
            // Note we bind it regardless of which view we on (only need for edit type views)
            if (this.model) {
                this.model.on("error:validation:" + this.name, this.handleValidationError, this);
                this.model.on('validation:start attributes:revert', this.removeValidationErrors, this);
            }
        },

        /**
         * Defines fallback rules for ACL checking.
         *
         * For example, if a user doesn't have `edit` permission for the given field
         * the template falls back to `detail` view template.
         */
        viewFallbackMap: {
            'edit': 'detail'
        },

        /**
         * Checks ACLs to see if the current user has access to action.
         *
         * @param {String} action Action name.
         * @return {Boolean} Flag indicating if the current user has access to the given action.
         * see {@link View.Field#_loadTemplate}
         */
        _checkAccessToAction: function(action) {
            return app.acl.hasAccessToModel(action, this.model, this.name);
        },
        /**
         * Returns fallback template for view
         *
         * @param {string} viewName
         * @return {string}
         * @protected
         */
        _getFallbackTemplate: function(viewName) {
            return (this.isDisabled() && viewName === 'disabled') ? 'edit' :
                (this.view.fallbackFieldTemplate || 'detail');
        },
        /**
         * Loads template for this field.
         * @private
         */
        _loadTemplate: function() {
            var fallbackFieldTemplate;

            // options.viewName or view metadata type is used to override the template
            var viewName = this.options.viewName || this.options.def.view ||
                (this.view.meta && this.view.meta.type ? this.view.meta.type : this.view.name);

            var actionName = this.action;
            if (this.isDisabled() && viewName === 'edit') {
                viewName = this.action;
            } else {
                actionName = this.action || (this.view.action && this.view.name != this.view.action ? this.view.action : viewName);
            }

            while (viewName) {

                if (this._checkAccessToAction(actionName)) break;
                viewName = this.viewFallbackMap[viewName];
                actionName = viewName;
            }

            if (viewName) {
                // Set fallback template to base/view or default.
                var moduleName = this.module || this.context.get('module');

                fallbackFieldTemplate = this._getFallbackTemplate(viewName);
                this.template = app.template.getField(this.type, viewName, moduleName, fallbackFieldTemplate) ||
                                // Fallback to text field if template is not defined for this type
                                app.template.getField("base", viewName, moduleName, fallbackFieldTemplate) ||
                                // Safeguard with an empty template
                                app.template.empty;
            } else {
                // Safeguard with an empty template
                this.template = app.template.empty;
            }

            // Update template name and action.
            // These properties are useful for a client app to make decisions when formatting values, rendering, etc.
            /**
             * Template (view) name.
             *
             * The view name can be different from the one the field belongs to.
             * The template is selected based on ACLs. It may also be overridden by field's metadata definition.
             * @property {String}
             * @member View.Field
             */
            this.tplName = viewName;
            /**
             * Action name.
             *
             * The action the field is rendered for. Usually, the action name equals to {@link View.Field#tplName}.
             * @property {String}
             * @member View.Field
             */
            this.action = actionName;
        },

        /**
         * Override default Backbone.Events to also use custom handlers.
         *
         * The events hash is similar to Backbone.View events hash.
         * You can specify event handler as method of field or as name of event
         * that should be triggered. You cannot use javascript code in metadata.
         * The framework stores the event handlers as anonimous function binded
         * to this field as part of the field instance with the `"callback_"`
         * prefix. When event is fired it calls `triggerMetadataEvent` method
         * if it exists in field. The default behavior of `triggerMetadataEvent`
         * is implemented in {@link app.plugins.MetadataEventDriven} plugin.
         *
         * <pre><code>
         * events: {
         *     handler: triggerSomeEvent;
         * }
         * </code></pre>
         *
         * triggerSomeEvent should be method of certain field.
         *
         * OR
         *
         * <pre><code>
         * events: {
         *     handler: "fire:some:event";
         * }
         * </code></pre>
         *
         * @private
         * @param {Object} events Hash of events and their handlers
         */
        delegateEvents: function(events) {
            // We may have:
            // this.events -- comes from custom .js controllers
            // this.def.events -- comes from metadata. See, for example, buttons section in portal.js file
            events = events || this.events || (this.def ? this.def.events : null);
            if (!events) return;

            events = _.clone(events);

            _.each(events, function(eventHandler, handlerName) {

                var callback = this[eventHandler];

                // If our callbacks / events have not been registered in field,
                // go ahead and registered it as method.
                if (!callback && _.isString(eventHandler)) {
                    callback = _.bind(function(event) {
                        if (_.isFunction(this.triggerMetadataEvent)) {
                            this.triggerMetadataEvent(event, eventHandler);
                        }
                    }, this);
                    this['callback_' + handlerName] = callback;
                    events[handlerName] = 'callback_' + handlerName;
                }

                if (!_.isFunction(eventHandler) && !callback) {
                    delete events[handlerName];
                }
            }, this);

            Backbone.View.prototype.delegateEvents.call(this, events);
        },

        /**
         * Renders a field widget.
         *
         * This method checks ACLs to choose the correct template.
         * Once the template is rendered, DOM changes are bound to the model.
         * @return {View.Field} The instance of this field.
         *
         * @protected
         */
        _render: function() {
            this._loadTemplate();
            if (this.model instanceof Backbone.Model) {
                /**
                 * Model property value.
                 * @property {String}
                 * @member View.Field
                 */
                this.value = this.getFormattedValue();
            }

            /**
             * The direction of the field. The default value `undefined` means
             * that the field would use the inherited direction from the DOM.
             *
             * Override this property with a specific direction string if the
             * field has a set direction that it always follows.
             *
             * Override this property with a function if logic is needed to
             * determine the direction of the field. The function should return
             * either a `string` indicating the direction of the field or
             * `undefined`. This function is only called after the value is set
             * so that we can base the direction on the value.
             *
             * Example using a function
             *
             *      direction: function() {
             *          return this.isRTL ? 'rtl' : 'ltr';
             *      }
             *
             * @property {string|Function|undefined} direction
             * @return {string|undefined}
             * @member View.Field
             */
            /**
             * The direction attribute for the field to be used in the template.
             *
             * @property {string|undefined} dir
             * @member View.Field
             */
            this.dir = _.result(this, 'direction');
            if (app.lang.direction === this.dir) {
                delete this.dir;
            }

            this.unbindDom();
            this.$el.html(this.template(this) || '');

            // Adds classes to the component based on the metadata.
            if(this.def && this.def.css_class) {
                this.getFieldElement().addClass(this.def.css_class);
            }

            this.$(this.fieldTag).attr('dir', this.dir);

            this.bindDomChange();
            return this;
        },

        /**
         * Get the correspond field DOM element
         *
         * This method will return the placeholder element.
         * Override this method in the subclass to point the specified field element
         *
         * @return {Object} DOM Element
         */
        getFieldElement: function() {
            return this.$el;
        },

        /**
         * Binds DOM changes to a model.
         *
         * The default implementation of this method binds value changes of {@link View.Field#fieldTag} element
         * to model's `Backbone.Model#set` method. Override this method if you need custom binding.
         */
        bindDomChange: function() {

            if (!(this.model instanceof Backbone.Model)) return;

            var self = this;
            var el = this.$el.find(this.fieldTag);
            el.on("change", function() {
                self.model.set(self.name, self.unformat(el.val()));
            });
        },

        /**
         * Binds model changes to this field.
         *
         * The default implementation makes sure this field gets re-rendered
         * whenever the corresponding model attribute changes.
         */
        bindDataChange: function() {
            if (this.model) {
                this.model.on("change:" + this.name, function(model, value) {
                    // FIXME: we need to track the `options` send by
                    // `model.set()` and only call `this.render()` if it didn't
                    // came from `bindDomChange`
                    if (this.action === 'edit') {
                        // Should directly set the value in edit instead of re-rendering the whole field (see MAR-1617).
                        this.$(this.fieldTag).val(this.format(value));
                    } else {
                        this.render();
                    }
                }, this);
            }
        },

        /**
         * Formats the value to be used in handlebars template and displayed on
         * screen.
         *
         * The default implementation returns `value` without modifying it.
         * Override this method to provide custom formatting in field
         * controller (`[type].js` file).
         *
         * @param {Array/Object/String/Number/Boolean} value The value to format.
         * @return {Array/Object/String/Number/Boolean} Formatted value.
         */
        format: function(value) {
            return value;
        },

        /**
         * Unformats the value for storing in a model. This should do the
         * inverse of {@link #format}.
         *
         * The default implementation returns `value` without modifying it.
         * Override this method to provide custom unformatting in field
         * controller (`[type].js` file).
         *
         * @param {String} value The value to unformat.
         * @return {Array/Object/String/Number/Boolean} Unformatted value.
         */
        unformat: function(value) {
            return value;
        },

        /**
         * Returns the value of this field in the associated model.
         *
         * If you need to override the formatted value please override
         * {@link #format}.
         *
         * @return {Array/Object/String/Number/Boolean} The formatted data as
         *   provided by {@link #format}.
         */
        getFormattedValue: function() {
            return this.format(this.model.has(this.name) ? this.model.get(this.name) : null);
        },

        /**
         * Handles validation errors.
         *
         * The default implementation does nothing.
         * Override this method to provide custom display logic.
         * <pre><code>
         * app.view.Field = app.view.Field.extend({
         *     handleValidationError: function(errors) {
         *       // Your custom logic goes here
         *     }
         * });
         * </code></pre>
         *
         * @param {Object} errors hash of validation errors
         * @template
         */
        handleValidationError: function(errors) {
            // Override this method
        },

        /**
         * Removes the validation error properties on the field that were set by
         * {@link #handleValidationError}.
         *
         * The default implementation does nothing.
         *
         * Override this method to provide custom logic:
         *
         *      @example
         *      app.view.Field = app.view.Field.extend({
         *          removeValidationErrors: function(errors) {
         *              // Your custom logic goes here
         *          }
         *      });
         *
         * @template
         */
        removeValidationErrors: function() {
            // Override this method
        },

        /**
         * Gets HTML placeholder for a field.
         * @return {String} HTML placeholder for the field as Handlebars safe string.
         */
        getPlaceholder: function() {
            return new Handlebars.SafeString('<span sfuuid="' + this.sfId + '"></span>');
        },

        /**
         * Disables the edit mode by switching the element as detail mode
         * @param {Boolean} true or undefined to disable the edit mode
         *               otherwise, it will restore back to the previous mode
         */
        setDisabled: function(disable) {
            disable = _.isUndefined(disable) ? true : disable;

            if(disable && this.isDisabled() === false) {
                //Set disabled
                this._previousAction = this.action;
                this.action = 'disabled';
                this.render();
            } else if(disable === false && this.isDisabled()) {
                //disabled release
                this.action = this._previousAction;
                delete this._previousAction;
                this.render();
            }
        },

        /**
         * Is the field disabled?
         * @return {Boolean} true if the field is disabled, false otherwise.
         */
        isDisabled: function() {
            return (this.action === 'disabled');
        },

        /**
         * Set view name of this field.
         * This only switches the template reference.
         * @param {String} view name.
         */
        setViewName: function(view) {
            this.options.viewName = view;
        },

        /**
         * Set action name of this field.
         * This switches action name as well as the template reference.
         *
         * @param name {String} action name
         **/
        setMode: function(name) {
            if(this.isDisabled()) {
                this._previousAction = name;
            } else {
                this.action = name;
            }
            this.setViewName(name);
            this.render();
        },

        /**
         * Unbinds DOM changes from field's element.
         *
         * This method performs the opposite of what {@link View.Field#bindDomChange} method does.
         * Override this method if you need custom logic.
         */
        unbindDom: function() {
            this.$el.find(this.fieldTag).off();
        },

        /**
         * Disposes a field.
         *
         * Calls {@link View.Field#unbindDom} and {@link View.Component#_dispose} method of the base class.
         * @protected
         */
        _dispose: function() {
            app.plugins.detach(this, "field");
            this.unbindDom();
            app.view.Component.prototype._dispose.call(this);
        },

        /**
         * Gets a string representation of this field.
         * @return {String} String representation of this field.
         */
        toString: function() {
            return "field-" + this.name + "-" + this.sfId + "-" +
                app.view.Component.prototype.toString.call(this);
        },

        /**
         * Set current element's display property to be shown
         */
        show: function() {
            if (!this.isVisible()) {
                if (!this.triggerBefore("show")) {
                    return false;
                }

                this.getFieldElement().removeClass("hide").show();

                this.trigger('show');
            }
        },

        /**
         * Set current element's display property to be hidden
         */
        hide: function() {
            if (this.isVisible()) {
                if (!this.triggerBefore("hide")) {
                    return false;
                }

                this.getFieldElement().addClass("hide").hide();

                this.trigger('hide');
            }
        },

        /**
         *  Visibility Check
         */
        isVisible: function() {
            return this.getFieldElement().css('display') !== 'none';
        },

        /**
         * Compare formatted values for equality.
         *
         * @param {Field} other Other field component.
         * @return {Boolean} It returns `true` for equal value.
         */
        equals: function(other) {
            return this.type === other.type && _.isEqual(this.getFormattedValue(), other.getFormattedValue());
        },

        /**
         * @inheritDoc
         */
        closestComponent: function(name) {
            if (!this.view) {
                return;
            }
            if (this.view.name === name) {
                return this.view;
            }
            return this.view.closestComponent(name);
        }
    });


})(SUGAR.App);

